# Containers

**여러 개의 값을 저장**할 수 있는 object

- 안에는 `int`, `float`, `str`, `bool` 등등, 다양한 자료형이 들어갈 수 있다.

    안의 값 없이 컨테이너 자체의 의미는 없지만, 컨테이너 없이 데이터만 쓰기에는 데이터가 많아질 때 너무 복잡해진다.

    컨테이너와 값은 서로 상호보완적인 관계


## 시퀀스형

컨테이너 내부의 값들에 **순서**가 존재

정렬(sorted)된 게 아니라, 컨테이너에서 n번째 값을 꺼낼 수 있다는 뜻임


### 종류

#### **List `[]`**

- 가장 많이 사용하는 컨테이너

    어지간한건 다 들어가고, 가장 제약조건이 없어 어디에나 사용할 수 있다.

```py
list1 = []
list2 = list()
```
- 리스트를 만들 때는 보통 1번 방식을 사용함. `list()`는 생성보다는 다른 컨테이너를 리스트로 바꿔줄 때 사용한다.

- list의 변수명은 항상 복수형을 사용하는게 좋다. (실제로 안에 데이터가 여러개 들어갈거니까)

#### **Tuple`()`**

- 리스트와 대부분의 기능을 공유함

- 리스트와 다른 점은, 튜플은 수정 불가능(Immutable, Hashable)함.

    수정 불가능하다는 것은 내부에 값을 추가/삭제/변경할 수 없다는 것.

- 직접 사용하기 보다는 파이썬 내부에서 주로 사용된다.

    ```py
    x, y = 1, 2
    y, x = x, y
    # (x, y) = (1, 2)
    # (y, x) = (x, y)
    ```
    파이썬에서, 괄호 없이 콤마로 구분된 값들을 튜플로 인식해서 사용한다.

- 끝에 `,`를 붙이는 것도 국룰이 있다.

    단일 항목 튜플의 경우, 소괄호와 구분되지 않아 끝에 `,`를 붙여주어야 한다.

    복수 항목 튜플은 코드를 여러 줄로 써야 할 때 끝에 `,`를 달아주는게 좋다.

#### **Range**

- 정수 값의 배열을 나타내기 위해 사용됨

- 기본형은 `range(start, end, step)`

    start부터, end 미만의 정수를 step만큼 더해가면서 배열하고, start를 생략하면 0부터, step을 생략하면 +1을 기본으로 한다.

    보통 많이 쓸 `range(n)`은 0부터 n-1까지의 모든 정수를 가진 배열

- range는 저장될 때 배열의 모든 숫자를 메모리에 넣는 게 아닌, range generator만 메모리에 저장하고, 만약 range 내부의 값을 꺼내 써야 할 때 전체 내용을 메모리에 적는다.

    그래서 메모리 절약에 좋음

#### **String**

- 스트링은 데이터 타입이지만, 리스트와 똑같이 인덱싱이 가능함(순서가 있다는 뜻). 

    ```py
    fruit = 'apple'
    fruit[0]
    # >> a
    ```

    간단하게 생각해서 `'apple'`을 `['a','p','p','l','e']` 처럼 되어 있는걸로 볼 수도 있다.


### 시퀀스형 연산자

- `+`: 산술 연산자

    시퀀스 둘을 서로 연결(concatenation)한다.
    ```py
    [1, 2] + ['a']
    # >> [1, 2, 'a']

    '12' + 'a'
    # >> '12a'
    ```
    - 리스트와 튜플, 스트링에서 적용된다.

    - 레인지는 당연히 안된다
        ```py
        range(2) + range(2, 5)
        # TypeError: unsupported operand type(s) for +: 'range' and 'range'
        ```

- `*`: 반복 연산자

    시퀀스를 n번 반복한다.

    ```py
    [1, 2] * 3
    # >> [1, 2, 1, 2, 1, 2]
    ```
    - 역시 리스트, 튜플, 스트링에서는 되고 레인지는 불가

        같은 시퀀스를 n번 더한다고 생각하면 된다.

### 인덱싱(indexing)

- n번째 값을 꺼내는 걸 인덱싱이라 한다.

- 모든 시퀀스형 컨테이너에서 사용할 수 있고, 방식은 다음과 같다.

    ```py
    sample = [1,2,3,4,5,6,7,8,9]
    print(sample[0])
    # >> 1
    print(sample[1])
    # >> 2
    ```
- **가장 중요한 건 숫자 세기가 0부터 시작한다는 것**

- 가끔 컨테이너 안에 컨테이너가 들어있는 경우가 있다.

    이럴 때도 인덱싱을 이용해 내부 값들을 꺼낼 수 있다.
    ```py
    sample = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    print(sample[0])
    # >> [1, 2, 3]
    print(sample[1][2])
    # >> 6
    ```

- 파이썬만의 특징으로, 역방향 인덱싱이 가능하다.
    ```py
    sample = [1,2,3,4,5,6,7,8,9]
    # 일반적으로 역방향 계산하는법
    print(sample[len(sample)-1])

    # 힙스터병 걸린 파이썬만의 방법
    print(sample[-1])
    # >> 9
    ```
    `[0]`이 가장 앞에 있는 첫 번째 값을 보여주고 있으니, `[-1]`은 그 왼쪽 데이터를 의미한다.

    가장 끝 값을 `[-1]`로 하고, 하나씩 왼쪽으로 올수록 -1씩 해주면 된다.


### 슬라이싱(slicing)

시퀀스[start:end:step]

```py
print([1, 2, 3, 4][1:3])
# >> [2, 3]
```
- 시작 인덱스 이상 ~ 끝 인덱스 미만의 인덱스를 가진 값들을 반환함

- `[:2]`처럼 비어있다면 시작이나 끝을 의미함

    ```py
    print('abcdef'[::2])
    # >> 'ace'
    print('abcdef'[::-1])
    # >> 'fedcba'
    ```
- step은 인덱스 값에 n만큼 더해서 다음 인덱스를 반환함.


### 패킹/언패킹

모든 시퀀스형은 `*`을 이용해 값들을 패킹/언패킹 할 수 있다.


- 패킹
    ```py
    x, y = 1, 2, 3
    # ValueError: too many values to unpack (expected 2)
    x, *y = 1, 2, 3
    print(x, y)
    # >> 1 [2, 3]
    x, y, *z = range(5)
    print(x, y, z)
    # >> 0 1 [2, 3, 4]
    ```

    - 변수에 값을 저장할 때 일반적으로는 하나씩만 저장하게 된다.

        개수가 맞지 않으면 에러가 나지만, `*`이 붙은 변수가 있다면 여기에 나머지 값들을 전부 리스트 형태로 짬처리

    - `*`은 항상 가장 뒷 변수에 들어간다(중간 변수에 넣을수는 있지만, 함수에서 에러가 난다.)

- 언패킹

    ```py
    def mult(x, y, z):
        return x * y * z
    
    numbers = [1, 2, 3]
    
    multiply(numbers)  # multiply([1, 2, 3])
    # >> TypeError: multiply() missing 2 required positional arguments: 'y' and 'z'
    multiply(*numbers)  # multiply(1, 2, 3)
    # >> 6
    ```
    시퀀스형 컨테이너(str 제외)를 풀어서 각 변수에 할당해준다.


## 비시퀀스형

순서가 없다는 것은 인덱스로 값을 불러올 수 없다는 것을 뜻한다.

### 종류

#### **Set**

- 수학에서의 집합을 나타내기 위해 만들어진 컨테이너라고 볼 수 있다.
    
    집합에서 사용하는 다양한 계산을 할 수 있다.

    s1 = {1, 2, 3}, s2 = {3, 4, 5}일 때,

    - 차집합 `-`
        ```py
        s1 - s2
        # >> {1, 2}
        ```

    - 합집합 `|`
        ```py
        s1 | s2
        # >> {1, 2, 3, 4, 5}
        ```

    - 교집합 `&`
        ```py
        s1 & s2
        # >> {3}
        ```

- 빈 세트를 만들 때는 `set()`밖에 쓸 수 없다. (`{}`는 딕셔너리에 뺏겼다)

- 세트의 가장 중요한 특징은, **내부에 중복을 허용하지 않는다**는 것임

    set를 조금 사도적으로 이용하면, list의 순서는 무시하고 중복된 값을 제거할 때 사용할 수 있다.

    ```py
    l = [1, 2, 3, 4, 1, 2]
    list(set(l))
    # >> [1, 2, 3, 4]
    ```

#### **Dictionary`{}`**

`{key1: value1, key2: value2, key3: value3, ...}`

- 순서에 따른 인덱스 대신, 직접 인덱스를 지정하고 싶을 때 이용한다.

    - 직접 지정한 인덱스를 **key**, 중요한 값을 **value**라고 한다.

    - 딕셔너리의 키는 중복이 불가능하고, 변경 불가능(immutable)한 데이터만 가능하다.

- 만들 때 `{}` 또는 `dict()`를 이용할 수 있지만, 주로 `{}`를 이용한다.

- 비시퀀스형이라 순서에 따른 인덱싱을 지원하지 않는다.

- 여러 method들을 사용할 수도 있다.

    ```py
    phone_book = {
        '서울': '02', 
        '경기도': '031', 
        '인천': '032', 
        '광주': '062', 
        '충청': '041',
    }

    print(phone_book)
    # >> {'서울': '02', '경기도': '031', '인천': '032', '광주': '062', '충청': '041'}
    print(phone_book['서울'])
    # >> '02'
    ```
    인덱스를 직접 지정해 줬으니(key), 값을 불러올 때도 인덱스와 똑같이 `[]`로 불러올 수 있다.

    - `.keys()`
        ```py
        phone_book.keys()
        # >> dict_keys(['서울', '경기도', '인천', '광주', '충청'])
        ```
        딕셔너리의 키들을 리스트로 불러옴

    - `.values()`
        ```py
        phone_book.values()
        # >> dict_values(['02', '031', '032', '062', '041'])
        ```
        딕셔너리의 값들을 리스트로 불러옴

    - `.items()`
        ```py
        phone_book.items()
        # >> dict_items([('서울', '02'), ('경기도', '031'), ('인천', '032'), ('광주', '062'), ('충청', '041')])
        ```
        딕셔너리의 키와 밸류를 튜플로 묶고, 이 쌍들을 리스트로 불러옴
        

## 컨테이너 간의 형변환

컨테이너는 서로 변환할 수 있다.

| | string | list | tuple | range | set | dictionary | 
| --- | --- | --- | --- | --- | --- | --- |
| string | - | O | O | X | O | X |
| list | O | - |  O | X | O | X |
| tuple | O | O | - | X | O | X | 
| range | O | O | O | - | O | X | 
| set | O | O | O | X | - | X | 
| dictionary | O | O (key만) | O (key만) | X | O (key만) | - | 

- 모든 컨테이너는 string으로 변환할 수 있다.
    ```py
    str([1, 2, 3])
    # >> '[1, 2, 3]'
    ```
    그냥 컨테이너 양 옆에 `''`를 써서 str로 만듦. 왜 모든 컨테이너가 string이 될 수 있는지 보인다.

- list <-> tuple <-> set는 서로 자유롭게 변환할 수 있다.

    대신, set으로 변환 시 중복항목이 제거되고 순서가 사라지는 건 감안해야 한다.

- range로는 변환할 수 없다.

    range를 list로 변환하고, 다시 그대로 range로 변환해도 안됨

- dictionary는 key만 변환된다.

    ```py
    d = {'a': 1, 'b': 2, 'c': 3}
    list(d)
    # >> ['a', 'b', 'c']
    ```

## Hashable

set 안에 list를 원소로 추가하려고 하면 에러가 난다.

```py
s = {1, 2}
s.add([3, 4])
# TypeError: unhashable type: 'list'
```

list가 아닌, tuple을 추가하는 것은 가능하다.

```py
s = {1, 2}
s.add((3, 4))
print(s)
# >> {1, 2, (3, 4)}
```

list와 tuple의 차이는 안의 값을 바꿀 수 있는지 여부, 즉 immutable 차이밖에 없다.

**Hashable(내부 값이 주소가 아닌 값 자체로 저장) = immutable(내부 값을 바꿀 수 없다)**

set의 원소들, dictionary의 key들은 Hashable한 것들만 가능하다.

우리가 알고 있는 immutable한 것들을 알아보자.

- str, int, float, range, tuple은 모두 immutable하다.

    그래서 set의 원소로 int가 들어갈 수 있었음

## 데이터와 메모리의 관계

```py
from copy import deepcopy

l = [[1, 2], [3, 4]]
l1 = l  # X copy
l2 = l[:]  # Shallow copy
l3 = deepcopy(l)  # Deep copy

l1[0][0] = 9
l2[0][1] = 99
l3[1][0] = 999

print(l1)
# >> [[9, 99], [3, 4]]
print(l2)
# >> [[9, 99], [3, 4]]
print(l3)
# >> [[1, 2], [999, 4]]
```
변수에 직접적으로 저장되는 건 값의 주소에 가깝다.

l에는 리스트의 주소인 A가 저장되어 있고, 실제로 리스트가 저장된 곳에는 [1, 2]가 저장된 주소 B와 [3, 4]가 저장된 주소 C가 [B, C] 처럼 들어있는 것.

- `l1 = l`: Copy 아님

    `l1`이라는 변수에 `l`에 써있는 id인 A를 그대로 저장함

    `l1`의 값을 바꾸면 `l`의 값도 같이 바뀐다.

- `l2 = l[:]`: Shallow copy

    새로운 주소 D를 만들고, 여기에 `l`에 저장된 리스트인 [B, C]를 그대로 가져온다.

    1차원 리스트에서는 이걸로 충분하고, 실제로 1차원에서 `l2`의 값을 바꾸면 `l`에 적용되지 않는다.

    2차원 이상 리스트에서는 B와 C가 그대로이므로 `l2`의 가장 안쪽 값을 바꾸면 `l`에 그대로 적용됨

- `l3 = deepcopy(l)`: Deep Copy

    아예 `l`의 모든 값을 가져다가 새로운 주소에 저장한다.

    여기서는 A, B, C 모두 사용하지 않음

    `l3`의 값을 아무리 바꿔도 `l`에는 전혀 영향을 미치지 못한다.

이걸 이해하기 쉬운 방법은 폴더와 바로가기, 파일의 관계를 생각하면 편하다.

- `l1`은 폴더의 바로가기를 만들어서 거기서 작업을 하는 것

- `l2`는 폴더 안 파일의 바로가기를 만들고, 새로운 폴더에 넣은 것

- `l3`은 폴더 채로 복사해서 새로 붙여넣은 것

각 리스트의 id를 뽑아보면 바로 알 수 있음

```py
for x in [l1, l2, l3]:
    print(x)
    print(id(x), id(l) == id(x))
    print(id(x[0]), id(l[0]) == id(x[0]))

"""
결과

l1
1903825120768 True
1903825122496 True

l2
1903825121920 False 
1903825122496 True

l3
1903825120448 False
1903825120640 False
"""
```
`l1`은 바깥과 안쪽 리스트 모두의 id가 `l`과 같음

`l2`는 바깥쪽 리스트의 id는 다르지만, 안쪽은 같다

`l3`은 모두 id가 다르다


---

# [코드 시각화](https://pythontutor.com/visualize.html#mode=edit)

실제로 데이터가 메모리에 어떻게 저장되는지 보기가 좋다

위의 `## 데이터와 메모리의 관계`를 그대로 이 사이트에 넣어보자