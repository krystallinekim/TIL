# Methods

데이터 값들, 관계 등에 적용할 수 있는 명령어들

중요하고 자주 쓰는 것들에는 ★을 붙여서 강조표시함

## `Str`

> 문자열은 변경할 수 없고(immutable), 순서가 있고(ordered), 순회 가능하다.(iterable)

`dir(str)`로 모든 메서드 목록을, `help(str)`로 각 메서드에 대한 설명을 볼 수 있다.

### 문자열 조회/탐색

#### `.find(x)`

> 문자열에서 x의 첫 번째 위치(인덱스)를 반환함.

이 때, x는 한 글자 말고도 부분 문자열도 가능함.

만약 문자열 안에 x가 없다면, -1을 반환함

```py
a = 'apple'
a.find('p'), a.find('pl'), a.find('z')
# >> (1, 2, -1)
```

#### `.index(x)`

> `.find()`와 완벽하게 같은 기능을 하지만, 문자열 안에 x가 없다면, 에러를 낸다.

```py
a = 'apple'
a.index('p'), a.index('pl')
# >> (1, 2)
a.index('z')
# ValueError: substring not found
```

#### `.startswith(x)`, `.endswith(x)`

> 문자열이 x로 시작하거나 끝난다면 True, 그렇지 않다면 False를 반환함

```py
a = 'hello python!'
a.startswith('hell'), a.endswith('python')
# >> (True, False)
```


#### 기타 검증 관련 메서드

`.is`가 접두사면 반드시 `T/F`로 결과가 나온다.

글자 관련 메서드들
- `.isalpha()`
    
    문자열이 (숫자가 아닌)글자로만 이루어져 있는가?

-  `.isspace()`

    문자열이 공백으로(\n같은건 아예 문자로 치지 않음) 이루어져 있는가?

-  `.isupper()`
    
    문자열이 대문자로만 이루어져 있는가?

-  `.istitle()`
 
    문자열이 타이틀 형식(문자열 처음과 띄어쓰기 뒤가 모두 대문자)으로 이루어져 있는가? 

-  `.islower()`
    
    문자열이 소문자로만 이루어져 있는가?

숫자 관련 메서드들

- `.isdecimal()`

    문자열이 0~9까지의 수로만 이루어져 있는가?

- `.isdigit()`

    문자열이 숫자(③, ³ 등등, 숫자가 들어간 글자들)로 이루어져 있는가?

- `.isnumeric()`

    문자열을 수로 볼 수 있는가?

    로마자, 분수 같은것도 포함

숫자 관련 메서드들은 decimal < digit < numeric 순으로 범위가 넓어진다

### 문자열 변경

string은 immutable이다. 함수로 str의 내용을 바꾸는 건 불가능하기 때문에, 따로 변수에 저장하지 않으면 변경한 내용은 바로 사라진다.

즉, 아무리 method를 걸어도 원본은 그대로 원래 변수에 존재함

#### ★`.replace(old, new[, count])`

설명에서 [] 안쪽은 선택사항임

> `old` 글자를 `new`로 전부 바꾸되, `count`가 있다면 그 개수만큼만 변경

```py
a = 'yaya!'
b = 'woooowoo'

a.replace('y','h')
# >> 'haha!'

b.replace('o','',2)
# >> 'woowoo`
```
여기서 a와 b를 찍어보면 원래 값 그대로 나올 것

#### `.strip([chars])`

```py
a = '    hello    '

a.strip()
# >> 'hello'

a.lstrip()
# >> 'hello    '
```
> 양쪽, 혹은 한쪽 공백을 전부 제거함

안에 `chars`를 지정하면 그 문자를 제거한다.

#### ★★`.split([chars])`

> 문자열을 특정 단위(기본값은 띄어쓰기)로 나눠서 리스트로 반환함

없는 문자를 세퍼레이터로 쓰면 통째로 리스트에 넣어준다.
```py
a = '나는_배가_부르다'
a.split('_'), a.split('*')
# >> (['나는', '배가', '부르다'], ['나는_배가_부르다'])
```

split을 많이 쓰게 되는 부분은 `input()`값을 받을 때 띄어쓰기로 구분된 숫자를 정수로 받고 싶다던가, csv로 받은 파일을 리스트로 나눌 때 같은 경우 사용하게 된다.

```py
user_input = input().split()
```
붙어있는 문자열을 한글자씩 리스트에 넣고 싶을 때, `.split('')`는 에러를 낸다

```py
a.split('')
# ValueError: empty separator
list(a)
# >> ['나', '는', '_', '배', '가', '_', '부', '르', '다']
```

#### ★★`'separator'.join(iterable)`

`join`은 특이하게 separator 뒤에 붙이는 메서드이고, 괄호 안에 붙일 문자열을 넣는다.

> 문자열을 서로 붙여주는데, 그 사이에 separator를 넣는다.

같은 str 사이에서나 컨테이너 안의 원소들에도 사용 가능하다.

```py
word = '안녕하세요'
words = ['안녕', '하세요']

'!'.join(word)
# >> '안!녕!하!세!요'

'!'.join(words)
# >> '안녕!하세요'
```
붙이는 기준은 for에서 임시변수 할당하던 때를 생각해 보자.

str는 하나하나 끊어서 붙이고, list는 요소들 사이를 기준으로 붙여준다.


#### 대문자/소문자 관련

- `.capitalize()`

    앞글자를 대문자로 만들어 반환합니다.

- `.title()`

    어포스트로피(*'*)나 공백 이후를 대문자로 만들어 반환합니다.

- `.upper()`

    모두 대문자로 만들어 반환합니다.

- `lower()`

    모두 소문자로 만들어 반환합니다.

- `swapcase()`

    대소문자를 서로 변경하여 반환합니다.


## List

> 변경 가능하고(mutable), 순서가 있고(ordered), 순회 가능하다.(iterable)

**str과는 달리 변경이 가능함** -> 정말 많은 것이 바뀐다.

역시 `help()`와 `dir()`를 사용 가능함

솔직히 메서드를 주로 사용할 곳이 str과 list밖에 없다.


### ★★★ `.append(x)`

그 중에서도 가장 많이 사용하게 될 method

> 리스트의 맨 뒤에 값을 추가한다.

```py
a = [1, 2, 3]
a.append(4)
print(a)
# >> [1, 2, 3, 4]
```

`a.append(4)`만으로는 셀 결과창에 답이 나오지 않는다. `print(a)`를 해보면, 원래 리스트 자체에 새로운 값이 추가된 것을 볼 수 있다.

### `.extend(iterable)`

> 리스트의 뒤에 새로운 iterable(주로 리스트)를 붙인다.

사실 그냥 list concatenate, `+=` 쓰면 알아서 붙는다.

대신, 값의 형태에 조금 차이가 생긴다.

```py
a = [1, 2, 3]
a.append([4, 5])
a.extend([6, 7])
print(a)
# >> [1, 2, 3, [4, 5], 6, 7]
```
`append()`는 진짜 리스트를 그대로 요소로 갖다 넣었고, `extend()`는 리스트를 벗겨서 그 안의 요소만 붙여준 걸 알 수 있다.

이 특징은 str을 붙일 때 잘 보이는데,
```py
a = ['a', 'b', 'c']
a.extend('def')
print(a)
# >> ['a', 'b', 'c', 'd', 'e', 'f']
```
str을 최소단위로 잘라서 붙여넣은 것을 알 수 있다.

### `.insert(i, x)`

> 정해진 위치(인덱스)에 특정 값(x)을 추가한다.

솔직히 맨 뒤에 추가할거면 `append()`를 쓰고, insert는 주로 첫번째 자리나 중간 어딘가에 집어넣을 때 쓴다.

```py
a = [1, 2, 3, 4, 5]
a.insert(0, 0)
print(a)
# >> [0, 1, 2, 3, 4, 5]
```

### `.remove(x)`

> 리스트에서 값이 x인 첫 번째 항목을 삭제한다.

```py
a = [1, 2, 3, 1, 2]
a.remove(1)
print(a)
# >> [2, 3, 1, 2]
```
한번 더 `remove()`를 돌리면 
```py
a.remove(1)
print(a)
# >> [2, 3, 2]
```
더이상 1이 없는데, remove를 한번 더하면 에러가 난다.
```py
a.remove(1)
# ValueError: list.remove(x): x not in list
```

### ★★★ `.pop([i])`

append에 이어 진짜 많이 쓸 메서드 2

> 특정 위치(i, 인덱스)의 값을 삭제하고, 그 값을 반환한다.

i가 없으면 마지막 항목에 대해 `pop()`을 실행한다.

특이하게, `pop()`은 코드를 돌리면 값을 반환해 주는 함수이다. 즉, 이 값을 변수에 저장해서 다른데에 쓰는 게 가능하다.

```py
a = [1, 2, 3, 4]
b = a.pop()
print(a, b)
# >> ([1, 2, 3], 4)
```

### `.clear()`

> 리스트의 모든 결과를 삭제함

`= []`과는 약간의 차이가 있다. `=[]`가 새로운 리스트를 만들어 할당하는 거라면, `clear()`는 리스트는 그대로 두고 내용만 날리는 거라 id가 그대로이다.

### `.index(x)`

> 리스트에서 x값의 위치를 찾아 인덱스값을 반환함

찾는 값이 없다면 오류가 난다.
```py
a = [1, 2, 3, 4, 5]

a.index(3)
# >> 2

a.index(100)
# ValueError: 100 is not in list
```


### ★ `.count(x)`

> 리스트에서 원하는 값(x)의 개수를 반환한다.
```py
a = [1, 2, 3, 1, 2, 3, 1]
a.count(1)
# >> 3
```
잘 조합하면 리스트에서 원하는 값을 모두 삭제할 수도 있다.

### `.sort()`

> 리스트를 오름차순으로 정렬한다.

파라미터로 key와 reverse가 있다. key는 특정 기준으로 정렬할 때 쓰고, reverse는 내림차순으로 정렬할 때 쓴다.

`sorted()`함수도 리스트를 오름차순으로 정렬할 수 있다는 기능은 같다.

- `.sort()`는 실행하면 원본을 그대로 바꾸고, 원본을 출력하면 바뀐 상태로 출력된다.
- `sorted()`는 실행해도 원본이 바뀌지 않아 원본이 그대로 있다.


### `.reverse()`

> 리스트 안의 원소들을 거꾸로 뒤집는다.

내림차순으로 정렬할 때는 `.sort(reverse = True)`를 쓰고, 이건 순서만 거꾸로 뒤집는 것.

## Tuple

> 튜플은 순서가 있지만(ordered), 불변(immutable) 자료형이다.

값이 바뀌지 않기 때문에, 값을 변경하는 메서드는 아예 의미가 없고, 순서를 조회하는 메서드만 지원한다.

### `.count(x)`

> 튜플에서 x가 나오는 횟수를 반환한다.

리스트의 `.count(x)`와 같다.

### `.index(x)`

> 튜플에 있는, 첫 번째 x의 인덱스를 반환함

역시 리스트에서 보던 `index()`와 같다.

## Set

> 셋은 순서가 없고(unordered), 변경(mutable), 순회(iterable)는 가능하다.

내부에 중복을 허용하지 않는다는 점도 기억하자.

### `.add(elem)`

> 집합에 원소(elem)를 추가한다.

```py
a = {'사과', '바나나', '포도'}
a.add('수박')
print(a)
# >> {'포도', '수박', '사과', '바나나'}
```
### `.update(*others)`

> 여러 값들(iterable한 데이터 구조)을 집합에 한번에 추가한다.

```py
a = {'사과', '바나나', '포도'}
a.update({'수박', '토마토','포도'})
print(a)
# >> {'포도', '수박', '사과', '바나나', '토마토'}
```
set의 특성상, 중복은 무시하고 받아온다.

### `.remove(elem)`

> 집합에서 원소를 삭제한다. 없으면 에러를 낸다.

```py
a = {'사과', '바나나', '포도'}

a.remove('사과')
print(a)
# >> {'포도', '바나나'}

a.remove('토마토')
# KeyError: '토마토'
```

### `.discard(elem)`

> 집합에서 원소를 삭제한다. 대신, 원소가 없어도 에러를 내지 않는다.

집합 안에 원소가 있는지 없는지 확실하지 않을 때 쓸 수 있다.

## Dictionary

> 역시 변경, 순회가 가능하고, 순서가 없다

다만, {키:값}이 자료구조에 쌍으로 들어간 점을 고려해 보자.

### `.get(key[, default])`

> 키를 통해 값을 가져오고, 없으면 없다고 한다(에러를 내지 않는다)

키를 통해 값을 가져오는 건 `dict[key]`도 충분히 할 수 있지만, 이 방법으로는 없는 키를 가져오고 싶을 때 에러를 낸다.

키가 있는지 없는지 확실하지 않을 때 `.get()`을 쓰게 된다.

```py
d = {'a': 1, 'b': 2, 'c': 3}

print(d['d'])
# KeyError: 'd'

print(d.get('d'))
# None
```

기본적으로 `.get()`으로 없는걸 가져오면 None, 즉 아무것도 반환하지 않지만, 특정 값을 반환하게 할 수도 있다.

```py
print(d.get('d'), '없음')
# 없음
```

### `.setdefault(key[, default])`

`.get()`과 비슷한 동작을 한다.

> 키가 있다면 가져오되, 키가 없으면 없는 키를 삽입한 후 가져온다.

심지어, 값도 설정을 통해 넣을 수 있다.

```py
d = {'a': 1, 'b': 2, 'c': 3}

d.setdefault('d', 4)
print(d)
# >> {'a': 1, 'b': 2, 'c': 3, 'd': 4}
```

### `.pop()`

### `.update()`

목적이 있는건 있는상태에서 바꾸고, 없는건 새로 추가하면서 바꾸기

setdefault와의 차이는 가져오기가 없다는것

## 얕은 복사와 깊은 복사

복사 시 값과 화살표의 차이를 알아두자

값은 복사해도 되고, 화살표는 복사해도 그대로임








```py
from copy import deepcopy

l = [[1, 2], [3, 4]]
l1 = l  # X copy
l2 = l[:]  # Shallow copy
l3 = deepcopy(l)  # Deep copy

l1[0][0] = 9
l2[0][1] = 99
l3[1][0] = 999

print(l1)
# >> [[9, 99], [3, 4]]
print(l2)
# >> [[9, 99], [3, 4]]
print(l3)
# >> [[1, 2], [999, 4]]
```
변수에 직접적으로 저장되는 건 값의 주소에 가깝다.

l에는 리스트의 주소인 A가 저장되어 있고, 실제로 리스트가 저장된 곳에는 [1, 2]가 저장된 주소 B와 [3, 4]가 저장된 주소 C가 [B, C] 처럼 들어있는 것.

- `l1 = l`: Copy 아님

    `l1`이라는 변수에 `l`에 써있는 id인 A를 그대로 저장함

    `l1`의 값을 바꾸면 `l`의 값도 같이 바뀐다.

- `l2 = l[:]`: Shallow copy

    새로운 주소 D를 만들고, 여기에 `l`에 저장된 리스트인 [B, C]를 그대로 가져온다.

    1차원 리스트에서는 이걸로 충분하고, 실제로 1차원에서 `l2`의 값을 바꾸면 `l`에 적용되지 않는다.

    2차원 이상 리스트에서는 B와 C가 그대로이므로 `l2`의 가장 안쪽 값을 바꾸면 `l`에 그대로 적용됨

- `l3 = deepcopy(l)`: Deep Copy

    아예 `l`의 모든 값을 가져다가 새로운 주소에 저장한다.

    여기서는 A, B, C 모두 사용하지 않음

    `l3`의 값을 아무리 바꿔도 `l`에는 전혀 영향을 미치지 못한다.

이걸 이해하기 쉬운 방법은 폴더와 바로가기, 파일의 관계를 생각하면 편하다.

- `l1`은 폴더의 바로가기를 만들어서 거기서 작업을 하는 것

- `l2`는 폴더 안 파일의 바로가기를 만들고, 새로운 폴더에 넣은 것

- `l3`은 폴더 채로 복사해서 새로 붙여넣은 것

각 리스트의 id를 뽑아보면 바로 알 수 있음

```py
for x in [l1, l2, l3]:
    print(x)
    print(id(x), id(l) == id(x))
    print(id(x[0]), id(l[0]) == id(x[0]))

"""
결과

l1
1903825120768 True
1903825122496 True

l2
1903825121920 False 
1903825122496 True

l3
1903825120448 False
1903825120640 False
"""
```
`l1`은 바깥과 안쪽 리스트 모두의 id가 `l`과 같음

`l2`는 바깥쪽 리스트의 id는 다르지만, 안쪽은 같다

`l3`은 모두 id가 다르다


---

# [코드 시각화](https://pythontutor.com/visualize.html#mode=edit)

실제로 데이터가 메모리에 어떻게 저장되는지 보기가 좋다
