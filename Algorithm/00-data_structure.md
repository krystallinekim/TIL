# 자료구조론
실제 알고리즘 문제를 해결할 때에도 문제에서 주어진 정보를 어떻게 구조화할 것인지가 아주 중요한 문제이며, 가장 먼저 고민해야 할 부분이다.

## 기초

### 리스트
반복 가능하고(iterable), 가변적이며(mutable), 순서가 있는(sequence) 컨테이너 자료형이다.
다양한 자료형을 원소로 가질 수 있다.
리스트 컴프리헨션(list comprehension)
리스트 슬라이싱
💡
리스트 슬라이싱을 활용하여 리스트 일부를 복사하거나, 도려내거나, 수정할 수 있다.

### 문자열
파이썬의 문자열
💡
문자열은 반복 가능하고(iterable), 불변적이며(immutable), 순서가 있는(sequence) 자료형이다.
리스트와 마찬가지로 슬라이싱을 활용하여 문자열을 원하는 범위만큼 자를 수 있다.
다만 문자열은 불변이므로 원본을 수정하는 것은 불가능하다.

## 컨테이너
>>해시 테이블은 key, value의 형태로 자료를 저장하는 자료구조이다.

특정 key를 넣었을 때 1대1로 매칭되는 index가 있고 그 곳에 value가 저장된다.

이 때 value가 저장되는 곳을 해시 테이블이라고 한다.

key와 index를 1대1 매칭하기 위해서는 해시 함수(Hash Function)가 필요하다.
 
>>해시 함수(Hash Function)는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다.

특정 key를 해시 함수에 넣었을 때 반환되는 index값을 해시(hash)라고 한다.

해시 함수를 통해 key, value가 매핑되는 과정은 다음과 같다.

1. 입력된 key값이 해시 함수를 통해 해시값으로 반환된다.

2. 해시값은 해시 테이블의 index가 되며 해당 위치에 value값이 저장된다.
 
이 때 key는 index와 1대1 매칭이 되어야 하므로 key에는 가변적인(mutable) 값을 쓸 수 없다.

이러한 key의 성질을 해시 가능하다(hashable) 라고 한다.

해시 테이블 기반 자료구조(딕셔너리, 집합)는 아래와 같은 중요한 특징을 갖는다.

1. 중복을 허용하지 않는다.

2. 순서가 없다(인덱스를 이용한 데이터 조회가 불가능하다).

3. 해시 테이블 특성상 $O(1)$시간만에 검색과 조회가 가능하다.

### 딕셔너리

>>파이썬의 딕셔너리는 해시 테이블 자료구조를 기반으로 구현된다.

딕셔너리는 기본적으로 중괄호로 표현하며, key값을 이용해 value값을 조회할 수 있다.

이 때 key를 통해 value를 조회하는 과정이 순회가 아니라 매핑이므로 매우 빠르다.

구체적으로 딕셔너리는 삽입, 삭제, 조회, 탐색 연산이 모두 O(1)의 시간 복잡도를 가진다.

따라서 데이터 양이 많고, 검색과 조회 연산이 많을 때에는 리스트보다 딕셔너리를 사용하는 것이 유리하다.

키 에러 방지하기
1. 조건문을 이용하여 분기한다.
2. `defaultdict` 클래스를 활용한다
3. `.get()` 메서드를 활용한다.
4. `Counter` 모듈을 활용한다.

### 집합
반복 가능하고(iterable), 가변적이며(mutable), 순서가 없는(Non-sequence) 자료형이다.
집합 자료형은 수학의 집합 개념을 파이썬에서 활용하기 위해 만들어졌다.
딕셔너리와 마찬가지로 해시 테이블을 이용하여 구현되어 있다.
중괄호 또는 set() 내장함수를 이용하여 선언할 수 있다.
집합 자료형은 알고리즘 문제에서 주로 아래와 같이 활용된다.
1. 중복을 허용하지 않으므로 주어진 데이터의 중복을 제거할 필요가 있을 때 사용한다.
해시 테이블 특성상 O(1)시간만에 검색과 조회가 가능하다.
따라서 데이터의 양이 많고 검색과 조회가 자주 일어나는 경우 리스트보다 집합 자료구조를 사용하는 것이 유리하다.
알고리즘 문제에서는 특히 그래프 문제에서 방문기록지로 많이 활용된다.

## 스택/큐/데크

### stack

선입후출, 쌓인 무더기라고 생각할 수 있음

나중에 들어온 데이터가 가장 먼저 빠짐

리스트에서 `.append()`로 넣고, `.pop()`으로 빼면 된다 - 그냥 리스트로 구현이 쉬움

둘다 $O(1)$이므로, 매우 빠름

### queue

선입선출, 대기줄이라고 생각하면 편함

먼저 들어온 데이터가 먼저 빠짐

똑같이 $O(1)$인 `.append()`로 넣지만, `.pop(0)`은 $O(N)$의 시간복잡도를 가진다

### deque

deque는 큐를 구현하기 위한 클래스

double-linked list -> 배열의 양 끝에서 다 데이터 산입/추출 가능

대신 탐색이 $O(N)$이 걸린다

데이터를 뺄 때 `.popleft()`로 뺄 수 있음

## 트리

트리 = 그래프의 일종

트리는 비선형 자료구조로 **사이클이 없는 무방향 그래프**이다.

자르면 무조건 2분할이 됨 - 사이클이 없어서

자른 트리는 서브트리가 됨

전력망 문제도 트리임

### 구조

완전 그래프의 경우 V(노드)에 대해 E(간선)이 약 $V^2$개

트리에서는 V에 대해 E는 항상 V-1개

모든 노드에 대해 부모 노드가 1개 = 연결된 간선이 1개 -> (루트에는 없음)

루트노드는 맨 위의 노드, 더이상 자식이 없는 노드가 리프노드

루트에서 리프로 가는 간선 숫자(깊이) = 레벨

사실 어떤 노드를 잡고 위로 올려도 그게 루트노드가 됨

### 트리의 표현

그래프 > 트리 > 이진트리 > 완전이진트리 > 힙

일단 그래프에 포함되어서 그래프 할때처럼 인접리스트/행렬로도 표현 가능

인접 리스트는 공간적으로 매우 비효율적, 인접행렬도 가로로는 줄어도 세로는 그대로라 뭔가 비효율적임
```text
[[0, 0, 1, 1, 1, 0],  // 0번 노드 => 2, 3, 4번 노드와 연결
 [0, 0, 0, 0, 0, 1],  // 1번 노드 => 5번 노드와 연결
 [1, 0, 0, 0, 0, 0],  // 2번 노드 => 0번 노드와 연결
 [1, 0, 0, 0, 0 ,1],  // 3번 노드 => 0, 5번 노드와 연결
 [1, 0, 0 ,0, 0, 0],  // 4번 노드 => 0번 노드와 연결
 [0, 1, 0, 1, 0, 0]]  // 5번 노드 => 1, 3번노드와 연결
```
```
[[2, 3, 4], [5], [0], [0, 5], [0], [1, 3]]
```

이진트리 = 자식이 많아봐야 2개인 트리(0, 1, 2)

이진트리가 아닌 트리는 그냥 인접행렬로 표시하기

L, R 2개의 리스트로 표현 가능함

부모 기준으로, 부모 노드에 자식의 인덱스를 L(왼쪽 자식), R(오른쪽 자식) 2개만 써서 표현

idx| 0 | 1 | 2 | 3 | 4 | 5 | 
---|---|---|---|---|---|---|
 L | 2 | - | - | 5 | - | 1 |
 R | 4 | - | - | 0 | - | - |

빈 부분이 리프노드

자식 기준이라면, 인덱스에 부모노드의 번호를 저장하면 리스트 하나로도 표현 가능함

idx| 0 | 1 | 2 | 3 | 4 | 5 | 
---|---|---|---|---|---|---|
par| 3 | 5 | 0 | - | 0 | 3 |

빈 부분이 루트노드

### 완전 이진트리(★)

왼쪽부터 차례로 빈 곳 없이 채워진 이진트리

조건 하나만 추가하면 힙으로 변함

일반 이진트리처럼 L, R 2개 리스트로 표현 가능

근데 리스트 하나로도 가능함

T = [3, 2, 4, 5, 0, 1]

위에서부터 번호를 1부터 준다고 쳤을 때,

왼쪽 자식 인덱스는 부모인덱스 * 2

오른쪽 자식 인덱스는 부모인덱스 * 2 + 1

부모인덱스는 자식인덱스 // 2

### 포화 이진트리

모든 층에 들어갈수 있는 노드가 꽉 차있어야 함

레벨이 n레벨이라면, 총 노드 수가 $2^n-1$

포화 이진트리도 완전 이진트리

### 나머지

왼쪽 자식 자리가 비어있는 이진트리

그냥 L, R 2개로 표현

## 힙

부모노드의 값이 자식노드의 값보다 무조건 작은 완전 이진트리

최소값은 항상 루트노드에 존재 -> 수많은 값들 중에 최소값을 찾는 데 사용한다

최소값 갱신에 매우 짧은 시간이 필요

일차원 리스트라면 $O(N)$, 힙으로 만들면 $O(logN)$



