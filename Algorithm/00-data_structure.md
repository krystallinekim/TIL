# 자료구조론

## 기초

### 리스트

### 문자열

## 컨테이너

### 해시와 딕셔너리

### 집합

## 스택/큐/데크

### stack

선입후출, 쌓인 무더기라고 생각할 수 있음

나중에 들어온 데이터가 가장 먼저 빠짐

리스트에서 `.append()`로 넣고, `.pop()`으로 빼면 된다 - 그냥 리스트로 구현이 쉬움

둘다 $O(1)$이므로, 매우 빠름

### queue

선입선출, 대기줄이라고 생각하면 편함

먼저 들어온 데이터가 먼저 빠짐

똑같이 $O(1)$인 `.append()`로 넣지만, `.pop(0)`은 $O(N)$의 시간복잡도를 가진다

### deque

deque는 큐를 구현하기 위한 클래스

double-linked list -> 배열의 양 끝에서 다 데이터 산입/추출 가능

대신 탐색이 $O(N)$이 걸린다

데이터를 뺄 때 `.popleft()`로 뺄 수 있음

## 트리

트리 = 그래프의 일종

트리는 비선형 자료구조로 **사이클이 없는 무방향 그래프**이다.

자르면 무조건 2분할이 됨 - 사이클이 없어서

자른 트리는 서브트리가 됨

전력망 문제도 트리임

### 구조

완전 그래프의 경우 V(노드)에 대해 E(간선)이 약 $V^2$개

트리에서는 V에 대해 E는 항상 V-1개

모든 노드에 대해 부모 노드가 1개 = 연결된 간선이 1개 -> (루트에는 없음)

루트노드는 맨 위의 노드, 더이상 자식이 없는 노드가 리프노드

루트에서 리프로 가는 간선 숫자(깊이) = 레벨

사실 어떤 노드를 잡고 위로 올려도 그게 루트노드가 됨

### 트리의 표현

그래프 > 트리 > 이진트리 > 완전이진트리 > 힙

일단 그래프에 포함되어서 그래프 할때처럼 인접리스트/행렬로도 표현 가능

인접 리스트는 공간적으로 매우 비효율적, 인접행렬도 가로로는 줄어도 세로는 그대로라 뭔가 비효율적임
```text
[[0, 0, 1, 1, 1, 0],  // 0번 노드 => 2, 3, 4번 노드와 연결
 [0, 0, 0, 0, 0, 1],  // 1번 노드 => 5번 노드와 연결
 [1, 0, 0, 0, 0, 0],  // 2번 노드 => 0번 노드와 연결
 [1, 0, 0, 0, 0 ,1],  // 3번 노드 => 0, 5번 노드와 연결
 [1, 0, 0 ,0, 0, 0],  // 4번 노드 => 0번 노드와 연결
 [0, 1, 0, 1, 0, 0]]  // 5번 노드 => 1, 3번노드와 연결
```
```
[[2, 3, 4], [5], [0], [0, 5], [0], [1, 3]]
```

이진트리 = 자식이 많아봐야 2개인 트리(0, 1, 2)

이진트리가 아닌 트리는 그냥 인접행렬로 표시하기

L, R 2개의 리스트로 표현 가능함

부모 기준으로, 부모 노드에 자식의 인덱스를 L(왼쪽 자식), R(오른쪽 자식) 2개만 써서 표현

idx| 0 | 1 | 2 | 3 | 4 | 5 | 
---|---|---|---|---|---|---|
 L | 2 | - | - | 5 | - | 1 |
 R | 4 | - | - | 0 | - | - |

빈 부분이 리프노드

자식 기준이라면, 인덱스에 부모노드의 번호를 저장하면 리스트 하나로도 표현 가능함

idx| 0 | 1 | 2 | 3 | 4 | 5 | 
---|---|---|---|---|---|---|
par| 3 | 5 | 0 | - | 0 | 3 |

빈 부분이 루트노드

### 완전 이진트리(★)

왼쪽부터 차례로 빈 곳 없이 채워진 이진트리

조건 하나만 추가하면 힙으로 변함

일반 이진트리처럼 L, R 2개 리스트로 표현 가능

근데 리스트 하나로도 가능함

T = [3, 2, 4, 5, 0, 1]

위에서부터 번호를 1부터 준다고 쳤을 때,

왼쪽 자식 인덱스는 부모인덱스 * 2

오른쪽 자식 인덱스는 부모인덱스 * 2 + 1

부모인덱스는 자식인덱스 // 2

### 포화 이진트리

모든 층에 들어갈수 있는 노드가 꽉 차있어야 함

레벨이 n레벨이라면, 총 노드 수가 $2^n-1$

포화 이진트리도 완전 이진트리

### 나머지

왼쪽 자식 자리가 비어있는 이진트리

그냥 L, R 2개로 표현

## 힙

부모노드의 값이 자식노드의 값보다 무조건 작은 완전 이진트리

최소값은 항상 루트노드에 존재 -> 수많은 값들 중에 최소값을 찾는 데 사용한다

최소값 갱신에 매우 짧은 시간이 필요

일차원 리스트라면 $O(N)$, 힙으로 만들면 $O(logN)$



