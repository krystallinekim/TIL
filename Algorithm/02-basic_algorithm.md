# 기초 알고리즘

## 완전탐색 알고리즘
brute force

컴퓨터 연산량을 믿고 다 때려넣는 방법

초당 1억번 정도 연산이 가능해서 사실 그냥 이걸로 푸는게 편할수도 있다

다만, N번 계산하는 반복문을 한번만 중첩해도 시간복잡도는 $O(N^2)$

N이 10만정도 되고부터는 이 방법으로 안풀리기 시작함

## 투 포인터 알고리즘

start, end 포인터(left, right도 가능) 2개를 두고, 이걸 이동시켜가면서 계산함

예를 들어, 합이 5 이상인 경우의 수를 찾을 때, 합이 5보다 작으면 end를 옮기면서 합을 늘리고, 5를 넘어가면 start 포인터를 옮기면서 합을 줄여가는 것

포인터가 뒤로 안돌아가서 시간복잡도가 $O(N)$

같은 문제를 조합으로 풀면 경우의 수를 모두 계산해야 해서 $O(N^2)$

```py
nums = [1, 2, 3, 4, 2, 5, 3, 1, 1, 2]

s = e = 0                       # 좌/우 포인터
tmp = 0                         # 임시합을 담아줄 변수
cnt = 0                         # 경우의 수를 세어줄 변수

while True:
    if tmp < 5:                 # 임시합이 5보다 작은데
        if e >= 10:             # 더 더해줄 숫자가 없다면 로직 종료
            break
        else:                   # 있다면
            tmp += nums[e]      # e포인터 숫자 더해주고
            e += 1              # e포인터 옮기기

    elif tmp > 5:               # 임시합이 5보다 크다면
        tmp -= nums[s]          # s포인터 숫자 빼주고
        s += 1                  # s포인터 옮기기

    else:                       # 임시합이 5와 동일하다면
        cnt += 1                # 숫자 세주고
        tmp -= nums[s]          # s포인터 숫자 빼주고
        s += 1                  # s포인터 옮기기

print(cnt)
```
코드 보면서 직접 포인터 옮겨가면서 푸는게 편함

## 누적합 알고리즘

### 구간합 문제

### 슬라이딩 윈도우

```py
nums = [3, 5, 1, 4, 2]

tmp = max_num = sum(nums[:3])       # 첫 번째 구간합 구하기

for idx in range(2):                # 첫 번째는 이미 구했으므로
    tmp += nums[idx+3] - nums[idx]  # 새로운 구간합은 양 옆에서 빼고 더해주면 된다(슬라이딩 윈도우)
    max_num = max(max_num, tmp)     # 갱신

print(max_num)
```

### 누적합 알고리즘

처음부터 i번째 숫자까지 더한 구간합을 이용함
```py
nums = [3, 5, 1, 4, 2]

acc_nums = [0]
for num in nums:
    acc_nums.append(acc_nums[-1]+num)

print(acc_nums)
# [0, 3, 8, 9, 13, 15]
```
## 함수와 재귀함수

- 파이썬의 LEGB

    `global`, `nonlocal` -> 함수 안에 함수를 넣어야 할 때, 변수 재할당 시 사용 -> 많이 헷갈림

- set의 id 자르기
    
    이건 나중에 dfs같은데서 씀

### 메모이제이션

계산한 결과값을 캐싱해서 시간복잡도를 크게 개선

### 이진탐색 알고리즘

**정렬된** 배열에서 원하는 데이터를 찾아내는 알고리즘

left, right, mid(l+r//2)

원하는 데이터가 l-m / m-r 사이 어디에 있는지 보고, 나머지 반대를 날림

이제는 m이 left, r은 그대로 -> 다시 mid를 구하고, 원하는 데이터와 비교하고, 나머지를 날림

이걸 반복하다보면 계속 구간이 줄어들면서 검색, 언젠가 같아지면 결론

선형탐색에서, $O(N)$ -> 10개의 데이터를 10번 보는것

이진탐색에서는 10개의 데이터를 3번만 봐도 확인 가능함 -> $O(logN)$(엄밀히 말해서 $O(log_2N)$)

- 일단 정렬된 결과에서만 사용 가능 -> 선형탐색에서는 $O(N)$, 정렬($O(NlogN)$) + 이진($O(logN)$)

    -> 기본적으로 정렬된 것(시간, 높이, 길이, ...)이 존재함 -> 여기에 이진검색을 걸어버리면 된다.(나무자르기 문제같은거)

재귀함수 스타일로 풀던가
```py
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]

def binary_search(low, high, target):
    if low > high:                                      # 탐색 배열의 길이가 0보다 작아지면 탐색 종료(실패)
        return '찾지 못함'

    mid = (low + high) // 2                             # 배열의 가운데 수 집기

    if target == nums[mid]:                             # 일치하면 탐색 종료(성공)
        return mid
    elif target < nums[mid]:                            # 오른쪽 절반 덜기
        return binary_search(low, mid-1, target)
    elif target > nums[mid]:                            # 왼쪽 절반 덜기
        return binary_search(mid+1, high, target)

print(binary_search(0, len(nums)-1, 7))
```

while 반복문으로 풀면 된다
```py
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]

def binary_search(low, high, target):

    while low <= high:                  # 탐색 배열의 길이가 0보다 작아지면 탐색 종료(실패)
        mid = (low + high) // 2         # 배열의 가운데 수 집기

        if target == nums[mid]:         # 일치하면 탐색 종료(성공)
            return mid
        elif target < nums[mid]:        # 오른쪽 절반 덜기
            high = mid-1
        elif target > nums[mid]:        # 왼쪽 절반 덜기
            low = mid+1

    return '찾지 못함'

print(binary_search(0, len(nums)-1, 7))

```



## 정렬 알고리즘
안정 정렬 <-> 불안정 정렬

안정은 정렬했을 때 순서가 유지되는 정렬, 불안정은 순서가 유지되지 않는 정렬

버블, 카운팅, 병합 정렬은 안정 정렬, 선택, 퀵 정렬은 불안정 정렬

파이썬에서 `sort(key=lambda)`를 이용하면, 해당 함수에 대해 정렬 후 나머지는 **안정 정렬**을 한다

### 버블 정렬

### 카운팅 정렬

사실 집계만 해도 정렬이 된다

여기까지 하면 불안정 정렬

누적합 이용 -> 순서대로 뽑아서 안정 정렬이 되게 할 수 있다

누적합 = 몇번째 숫자인지

## 비트 연산
set에서, `a & b` = 교집합, `a | b` = 합집합

양 옆에 숫자(십진수)가 들어가면?

비트 계산은 O(1)짜리 계산이라 매우 빠르다

3 = 011(2), 

6 = 110(2)

& = AND 연산자

`3 & 6` = 2

교집합 -> 둘다 동시에 만족해야 함

둘 다 1이면 1, 다르면 0 -> `3 & 6` = 010(2) = 2

| = OR 연산자

`3 | 6` = 7

합집합 -> 둘중에 하나라도 만족하면 포함

`3 | 6` = 111(2) = 7

^ = XOR 연산자

둘이 다르면 포함

`3 | 6` = 101(2) = 5

<<, >> = 소수점 이동

왼쪽, 오른쪽 shift -> 왼쪽, 오른쪽으로 몇칸 옮기라는 뜻

`6 << 2` = 24

110(2) -> 11000(2) = 24

n자리 올리는건 결국 $2^n$배 하라는 것임

`6 >> 2` = 1

110(2) -> 1(2) -> 나머지는 버려서 답은 1

결국 $2^n$으로 나눈 몫

`~`: NOT, 부호 반전

안씀

### 부분집합

{A, B, C}의 부분집합은 총 8개($2^3$개)

부분집합| A | B | C |십진수
-------|---|---|---|------
{}|0|0|0|0
{A}|1|0|0|4
{B}|0|1|0|2
{C}|0|0|1|1
{A,B}|1|1|0|6
{B,C}|0|1|1|3
{A,C}|1|0|1|5
{A,B,C}|1|1|1|7

모든 집합의 부분집합은 연속된 정수로 나타낼 수 있어짐

부분집합인 특정 숫자 5는 컴퓨터는 미지의 이진수 101(2)로 처리됨.

손에 1을 들고, `AND`연산으로 맨 뒷자리부터 하나씩 확인하는 것(1 << 1, 한자리씩 왼쪽으로 옮김) 

즉, 1 & 5, 2 & 5, 4 & 5를 해서 값이 1인지, 0인지를 확인함

```py
# 비트를 활용한 부분집합 구하기
letters = ['a', 'b', 'c']

for i in range(1 << len(letters)):  # 2³, 2 ** 3을 비트스럽게 작성한 것
    selected = []  # 가져올 부분집합
    for j in range(len(letters)): #  j는 1(a), 2(b), 4(c)
        if i & (1 << j):  # 1칸씩 왼쪽으로 옮겨가며 총 3칸을 대조해본다.
            selected.append(letters[j]) # 대조 결과가 성공이라면 = 이번 부분집합에 letter가 들어있다면 append

    print(selected)

# []                | => (i = 0) => 0 0 0 => 공집합
# ['a']             | => (i = 1) => 0 0 1 => (j = 0)에서 걸려 'a'가 뽑힘
# ['b']             | => (i = 2) => 0 1 0
# ['a', 'b']        | => (i = 3) => 0 1 1
# ['c']             | => (i = 4) => 1 0 0 => (j = 2)에서 걸려 'c'가 뽑힘
# ['a', 'c']        | => (i = 5) => 1 0 1
# ['b', 'c']        | => (i = 6) => 1 1 0
# ['a', 'b', 'c']   | => (i = 7) => 1 1 1
```

어떤 집합의 모든 부분집합에 대해 접근이 가능해짐