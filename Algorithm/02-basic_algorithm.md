# 기초 알고리즘

## 완전탐색 알고리즘
brute force

컴퓨터 연산량을 믿고 다 때려넣는 방법

초당 1억번 정도 연산이 가능해서 사실 그냥 이걸로 푸는게 편할수도 있다

다만, N번 계산하는 반복문을 한번만 중첩해도 시간복잡도는 $O(N^2)$

N이 10만정도 되고부터는 이 방법으로 안풀리기 시작함

## 투 포인터 알고리즘

start, end 포인터(left, right도 가능) 2개를 두고, 이걸 이동시켜가면서 계산함

예를 들어, 합이 5 이상인 경우의 수를 찾을 때, 합이 5보다 작으면 end를 옮기면서 합을 늘리고, 5를 넘어가면 start 포인터를 옮기면서 합을 줄여가는 것

포인터가 뒤로 안돌아가서 시간복잡도가 $O(N)$

같은 문제를 조합으로 풀면 경우의 수를 모두 계산해야 해서 $O(N^2)$

```py
nums = [1, 2, 3, 4, 2, 5, 3, 1, 1, 2]

s = e = 0                       # 좌/우 포인터
tmp = 0                         # 임시합을 담아줄 변수
cnt = 0                         # 경우의 수를 세어줄 변수

while True:
    if tmp < 5:                 # 임시합이 5보다 작은데
        if e >= 10:             # 더 더해줄 숫자가 없다면 로직 종료
            break
        else:                   # 있다면
            tmp += nums[e]      # e포인터 숫자 더해주고
            e += 1              # e포인터 옮기기

    elif tmp > 5:               # 임시합이 5보다 크다면
        tmp -= nums[s]          # s포인터 숫자 빼주고
        s += 1                  # s포인터 옮기기

    else:                       # 임시합이 5와 동일하다면
        cnt += 1                # 숫자 세주고
        tmp -= nums[s]          # s포인터 숫자 빼주고
        s += 1                  # s포인터 옮기기

print(cnt)
```
코드 보면서 직접 포인터 옮겨가면서 푸는게 편함

## 누적합 알고리즘

### 구간합 문제

### 슬라이딩 윈도우

```py
nums = [3, 5, 1, 4, 2]

tmp = max_num = sum(nums[:3])       # 첫 번째 구간합 구하기

for idx in range(2):                # 첫 번째는 이미 구했으므로
    tmp += nums[idx+3] - nums[idx]  # 새로운 구간합은 양 옆에서 빼고 더해주면 된다(슬라이딩 윈도우)
    max_num = max(max_num, tmp)     # 갱신

print(max_num)
```

### 누적합 알고리즘

처음부터 i번째 숫자까지 더한 구간합을 이용함
```py
nums = [3, 5, 1, 4, 2]

acc_nums = [0]
for num in nums:
    acc_nums.append(acc_nums[-1]+num)

print(acc_nums)
# [0, 3, 8, 9, 13, 15]
```
## 함수와 재귀함수








## 정렬 알고리즘
안정 정렬 <-> 불안정 정렬

안정은 정렬했을 때 순서가 유지되는 정렬, 불안정은 순서가 유지되지 않는 정렬

버블, 카운팅, 병합 정렬은 안정 정렬, 선택, 퀵 정렬은 불안정 정렬

파이썬에서 `sort(key=lambda)`를 이용하면, 해당 함수에 대해 정렬 후 나머지는 **안정 정렬**을 한다

### 버블 정렬

### 카운팅 정렬

사실 집계만 해도 정렬이 된다

여기까지 하면 불안정 정렬

누적합 이용 -> 순서대로 뽑아서 안정 정렬이 되게 할 수 있다

누적합 = 몇번째 숫자인지
