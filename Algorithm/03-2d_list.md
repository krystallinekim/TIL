# 이차원 리스트

원소로 일차원 리스트를 갖는 리스트

```py
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```

줄바꿈을 하면 행렬과 같아짐.

`matrix[2][0]` = 7


- 행우선순회/열우선순회

둘다 기본적으로 $O(N^2)$의 시간복잡도를 가진다

이중 for문을 사용함

- 전치

행렬을 전치한다 = 그래프의 방향을 반대로 바꾼다

`zip()`를 사용함

리스트를 세로로 찝어서 튜플로 만들어주는 함수 -> 바로 전치됨

안의 리스트 길이가 다르면 짧은거 기준으로 자르고 나머지는 버림


```py
dict(zip(range(3), [0] * 3))
# >> {0: 0, 1: 0, 2: 0}
```
여러 자료구조를 합쳐서 원하는 구조를 만드는 것도 가능함

이차원 리스트를 회전시키는 것도 가능하다.

zip을 안쓰고 회전시키면 매우 귀찮음

```py
rotated_matrix_right = list(zip(*matrix[::-1]))
rotated_matrix_left  = list(zip(*matrix))[::-1]
```

`*`는 내부 리스트를 언패킹해야 해서 사용함

3x4같은 정사각형렬이 아닌 리스트도 회전시킬 수 있다.

## 그래프의 연결관계

- 인접행렬

```py
ways = [[0, 1, 1, 0],
        [1, 0, 1, 1],
        [0, 0, 0, 1],
        [0, 0, 1, 0]]
```
좋긴 한데, 노드가 많고 간선의 숫자가 적은 경우(주로 트리구조) - 버리는 데이터가 많아짐


- 인접 리스트

```py
ways = [[1, 2],
        [0, 2, 3],
        [3],
        [2]]
```

열을 압착해서 사용함. 0번 노드에서는 1, 2로, 1번 노드에서는 0, 2, 3으로 갈 수 있는걸 표현

간선 개수가 적을수록 유리함

다만, 알고리즘에서 공간복잡도와 시간복잡도는 반비례함

0번 노드 - 3번 노드가 인접해 있는가?

- 인접행렬: ways[0][2] -> $O(1)$
- 인접 리스트: 3 in ways[0] -> $O(N)$

또, 인접 리스트에서 가중치를 부여하려면 3차원 행렬이 되어버림

인접행렬에서는 ways[0][2] = 3 하면 바로 가중치가 부여됨

둘 다 사용해야 할 곳이 있음

기본적으로 완전 그래프(모든 노드가 서로 연결) 기준으로 시간복잡도는 똑같지만, 보통 인접 리스트가 조금 더 빠름

## 델타 탐색

특정 위치 기준으로 인접한 방향의 내용을 이용하고 싶을 때 사용함

좌표계를 이용할 때, 

새 좌표 = 기존좌표 + 델타값
```text
(x, y) --(dx, dy)--> (x', y')
(1, 1) --( 0, -1)--> ( 1, 0 )
(1, 1) --( 0, +1)--> ( 1, 2 )
(1, 1) --(-1,  0)--> ( 0, 1 )
(1, 1) --(+1,  0)--> ( 2, 1 )
```

행렬에서는 인덱스를 사용함(좌표랑 순서가 반대임)

```text
matrix[r][c] --(dr, dc)--> matrix[nr][nc]
상하이동: nr = r + dr (행인덱스에 +-)
좌우이동: nc = c + dc (열인덱스에 +-)
```

