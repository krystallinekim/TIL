# 비트 연산



set에서, `a & b` = 교집합, `a | b` = 합집합

양 옆에 숫자(십진수)가 들어가면?

비트 계산은 O(1)짜리 계산이라 매우 빠르다

3 = 011(2), 

6 = 110(2)

& = AND 연산자

`3 & 6` = 2

교집합 -> 둘다 동시에 만족해야 함

둘 다 1이면 1, 다르면 0 -> `3 & 6` = 010(2) = 2

| = OR 연산자

`3 | 6` = 7

합집합 -> 둘중에 하나라도 만족하면 포함

`3 | 6` = 111(2) = 7

^ = XOR 연산자

둘이 다르면 포함

`3 | 6` = 101(2) = 5

<<, >> = 소수점 이동

왼쪽, 오른쪽 shift -> 왼쪽, 오른쪽으로 몇칸 옮기라는 뜻

`6 << 2` = 24

110(2) -> 11000(2) = 24

n자리 올리는건 결국 $2^n$배 하라는 것임

`6 >> 2` = 1

110(2) -> 1(2) -> 나머지는 버려서 답은 1

결국 $2^n$으로 나눈 몫

`~`: NOT, 부호 반전

안씀

## 부분집합

{A, B, C}의 부분집합은 총 8개($2^3$개)

부분집합| A | B | C |십진수
-------|---|---|---|------
{}|0|0|0|0
{A}|1|0|0|4
{B}|0|1|0|2
{C}|0|0|1|1
{A,B}|1|1|0|6
{B,C}|0|1|1|3
{A,C}|1|0|1|5
{A,B,C}|1|1|1|7

모든 집합의 부분집합은 연속된 정수로 나타낼 수 있어짐

부분집합인 특정 숫자 5는 컴퓨터는 미지의 이진수 101(2)로 처리됨.

손에 1을 들고, `AND`연산으로 맨 뒷자리부터 하나씩 확인하는 것(1 << 1, 한자리씩 왼쪽으로 옮김) 

즉, 1 & 5, 2 & 5, 4 & 5를 해서 값이 1인지, 0인지를 확인함

```py
# 비트를 활용한 부분집합 구하기
letters = ['a', 'b', 'c']

for i in range(1 << len(letters)):  # 2³, 2 ** 3을 비트스럽게 작성한 것
    selected = []  # 가져올 부분집합
    for j in range(len(letters)): #  j는 1(a), 2(b), 4(c)
        if i & (1 << j):  # 1칸씩 왼쪽으로 옮겨가며 총 3칸을 대조해본다.
            selected.append(letters[j]) # 대조 결과가 성공이라면 = 이번 부분집합에 letter가 들어있다면 append

    print(selected)

# []                | => (i = 0) => 0 0 0 => 공집합
# ['a']             | => (i = 1) => 0 0 1 => (j = 0)에서 걸려 'a'가 뽑힘
# ['b']             | => (i = 2) => 0 1 0
# ['a', 'b']        | => (i = 3) => 0 1 1
# ['c']             | => (i = 4) => 1 0 0 => (j = 2)에서 걸려 'c'가 뽑힘
# ['a', 'c']        | => (i = 5) => 1 0 1
# ['b', 'c']        | => (i = 6) => 1 1 0
# ['a', 'b', 'c']   | => (i = 7) => 1 1 1
```

어떤 집합의 모든 부분집합에 대해 접근이 가능해짐