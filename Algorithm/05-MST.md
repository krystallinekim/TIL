# MST
최소신장트리, Minimum Spanning Tree

그래프에서 먼저 트리를 골라옴

트리를 골라온다는건 전체 그래프에서 전체 노드(V개)에 따른 간선(V-1개)을 트리 형태가 되도록 선택해야 한다는 것

최소신장 = 간선의 가중치의 합이 최소가 되게 선택하는 경우

즉, 노드는 전부 고르되, 간선은 가중치의 합이 최소가 되게 선택하는 트리가 MST

## 프림 알고리즘

그리디 알고리즘에 속함

> 현재 상황에서 최선을 선택하다보면 전체의 최선이 되는 것 -> 부분 최적의 결과가 전체의 최적이 되는 것임

1. distance 배열을 만든다
    목표 노드까지 도달하는데 필요한 거리, 일단 무한대로 초기화 [∞, ∞, ∞, ∞, ∞]
2. 첫번째 노드(0번)은 시작점, distance는 0 -> [0, ∞, ∞, ∞, ∞]
3. 시작점 -> 이어진 노드의 간선 중, 이동가능한 간선에 거리를 최신화 -> [0, 2, 10, ∞, ∞]
4. 0번 기준으로, 방문하지 않고, 거리가 최소인 노드(1번)로 이동, 거리정보를 최소값으로 갱신 -> [0, 2, 10, 8, 1]
5. 0-1 연결 기준으로, 방문하지 않고, 거리가 최소인 노드(4번)으로 이동, 거리정보 갱신 -> [0, 2, 3, 5, 1]
6. 0-1-4 기준으로 방문하지 않고, 거리가 최소인 노드(2번)으로 이동

- 여기서 distance 배열에서 최소값을 고를 때 heap으로 구함(시간절약부분)
- 시작점이 어디던지 상관없이, 항상 MST는 똑같이 나온다.

```py
n = 5
edges = [[5,2,6],[3,1,2],[2,3,5],[2,4,6]]	

from heapq import heappush, heappop

# dist를 전부 ∞로 통일
inf = float('inf')
dist = [inf] * (n+1)

# 그래프의 인접 리스트
adj = [[] * (n+1) for _ in range(n+1)]
for x, y, w in edges:
    adj[x].append((y, w))
    adj[y].append((x, w))

# 1번 노드에서 시작함
heap = [(0,1)]
dist[1] = 0
visited = set()

while heap:
    w, cur = heappop(heap)
    
    # heap에 다른데서 구한 긴 길이의 간선이 있을 때 계산하지 않고 넘어감
    if w > dist[cur]:
        continue
    
    # visited에 지금 찍은 노드를 추가
    visited.add(cur)
    
    # 인접리스트에서
    for y, w in adj[cur]:
        # 간선에 연결된 노드가 간적 없고 / 가중치가 기존 거리보다 짧을 경우
        if y not in visited and dist[y] > w:
            # 길이를 최신화하고
            dist[y] = w        
            # heap에 (가중치, 노드)를 추가함
            heappush(heap, (w, y))
            # 그럼 다음 heappop시 가장 가중치가 짧은 노드를 계산

print(dist[1:])
```
## 다익스트라 알고리즘
= 최단 거리 알고리즘

시작점 -> 종점까지의 최단 거리를 찾는 알고리즘

기본적으로, 간선의 가중치가 양수여야 함

프림이랑 거의 똑같은데, 가중치를 최신화하는게 아니라 가중치를 더해줌

가중치가 음수라면, 그리디 알고리즘으로 잡아낼 수가 없어진다.

이럴때는 벨만-포드같은걸 써주면 됨