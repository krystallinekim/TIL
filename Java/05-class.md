# 클래스

## 객체(Object)

- 객체란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성과 기능을 가지고 다른 것과 식별이 가능한 것을 말한다.

### 객체 지향 프로그래밍(OOP, Object-Oriented Programming)

- 프로그램을 개발하는 기법으로 객체들을 만들고 이러한 객체들을 연결해서 프로그램을 완성하는 기법을 객체 지향 프로그래밍이라고 한다.
- 객체 지향 프로그래밍 특성을 지원하는 언어를 객체 지향 프로그래밍 언어라고 한다.
    - 캡슐화: 외부에서 필드 접근을 차단하고, 메소드를 통해 간접적으로 접근 가능하게 막아놓는 것

### 객체 생성

- 클래스로부터 객체를 생성하려면 `new` 연산자를 사용해서 생성한다.
    
    ```java
    클래스명 변수명 = new 클래스명();  // 클래스명() -> 생성자 호출
    ```
    
- `new` 연산자는 Heap 영역에 객체를 생성하고 객체의 주소값을 리턴한다.

- 객체의 주소값을 *참조 타입인 변수*에 저장해서 객체를 사용할 수 있다.

    ```java
    // new 연산자와 클래스의 생성자를 사용해서 객체를 생성한다.
    Member member = new Member();
    ```

## 클래스

- 클래스는 객체의 특성(속성, 기능)을 정의하는 *설계도*이다.
    - 객체의 속성은 필드를 통해서 정의한다.
    - 객체의 기능은 메소드를 통해서 정의한다.

- 클래스로부터 메모리에 생성된 객체를 해당 클래스의 인스턴스(Instance)라고 한다.
    - **객체(Object)는 프로그램에서 구현할 대상**으로 이를 구현하기 위한 설계도가 클래스(Class)이고, 클래스로부터 메모리에 생성된 실체가 인스턴스(Instance)이다.
    - 한 클래스에서 여러 개의 인스턴스를 만들어 낼 수 있다.

### 클래스 선언

- 클래스를 선언하는 구문은 `[접근 제한자] [예약어] class 클래스명 { ... }`이다.
    - 클래스의 이름은 자바의 식별자 작성 규칙(앞글자는 대문자, 구분되는 단어 앞글자도 대문자)에 따라서 만들어야 한다.
    - 소스 파일의 이름은 반드시 선언된 클래스 이름과 같도록 해야 한다.
    - 정확히는 public 클래스의 이름과 같아야 함, 한 파일에 public은 하나만 생성 가능

- 접근 제한자는 public, default 설정이 가능하다.
    - 대부분 public을 사용한다. public은 아무 제약 없이 접근이 가능함
    - default라는 이름의 접근제한자는 없다 (접근제한자가 없다면 default가 된다.)

- 클래스에는 구성 멤버로 필드(Field), 메소드(Method), 생성자(Constructor)가 정의된다.
    
    ```java
    public class Member {
        // 필드, 생성자, 메소드 정의
        ...
    }
    ```

### 접근 제한자

- 자바에서 제공하는 접근 제한자는 public, protected, default, private 4가지 종류가 있다.
    
    | 구분 | 클래스 | 패키지 | 자식 클래스 | 전체 |
    | --- | --- | --- | --- | --- |
    | public(+) | O | O | O | O |
    | protected(#) | O | O | O | X |
    | default(~) | O | O | X | X |
    | private(-) | O | X | X | X |

- public 접근 제한자는 외부에서 자유롭게 접근이 가능하다.
- protected 접근 제한자는 같은 패키지 또는 자식 클래스에서만 접근이 가능하다.
- default 접근 제한자는 같은 패키지에 소속된 클래스에서만 접근이 가능하다.
- private 접근 제한자는 외부에서의 접근을 제한하고 선언된 클래스에서만 접근이 가능하다.


## 필드(Field)

- 필드는 객체의 데이터, 상태 등의 속성이 저장되는 공간이다.

- 선언 형태는 변수와 비슷함.
  
- 필드는 생성자와 메소드 전체(**클래스 내부 어디에서나**)에서 사용되며 객체가 생성되고 소멸되기 전까지 객체와 함께 존재한다.

- 객체 생성 시 메모리(Heap)에 이 필드 값들이 저장되고, 객체의 변수명에 그 주소가 저장된다.
    - 클래스가 자료형(사용자 정의 자료형)인 이유


### 지역변수와의 비교

- 필드는 멤버 변수, 인스턴스 변수라고 부르기도 하지만, 지역변수와는 차이가 있다.
  
    | 구분 | 필드 | 지역변수 |
    | --- | --- | --- |
    | 생성 위치 | 클래스 영역 | 메소드, 생성자, 제어문 등 |
    | 사용 위치 | 클래스 전역 | 생성된 구역에서만 |
    | 접근제한자 | O | X |
    | 생성 시점 | 객체(인스턴스) 생성 시 | 메소드, 생성자, 제어문 실행 시 |
    | 소멸 시점 | 객체 소멸 시 | 실행 종료시 |
    | 메모리 | Heap | Stack |
    | 초기값 | 기본 초기값 있음 | 초기화하지 않으면 사용 불가 |

### 필드 선언

- 필드를 선언하는 구문은 `[접근 제한자] [예약어] 자료형 변수명[ = 초기값];`이다.

- 필드 선언은 클래스 중괄호 블록 어디서든 존재할 수 있지만 생성자와 메소드 중괄호 블록 내부에는 선언될 수 없다.

- 접근 제한자는 4가지 모두 설정이 가능하다.
    - 특별한 경우가 아니면 필드는 `private`으로 선언함

- 필드의 초기값은 필드 선언 시 주어질 수도 있고, 생략될 수도 있다.
    - 초기값이 지정되지 않은 필드는 객체 생성 시 자동으로 기본 초기값으로 설정된다.
    
    ```java
    public class Member {
        // 필드 정의
        public String name; // 초기값 null
        private int age = 20;
      
        // 생성자, 메소드 정의
        ...
    }
    ```
    

### 필드 사용

- 클래스 내부에서 필드는 생성자와 모든 메소드에서 사용이 가능하다.

- 클래스 외부에서 필드를 사용하려면 클래스로부터 객체를 생성하고 필드를 사용해야 한다.
    - 접근 제한자가 public인 필드의 경우 도트(.) 연산자를 사용해서 어디서나 필드에 접근할 수 있다.
    - private인 경우, 직접 접근이 불가하므로 메소드를 이용해 간접적으로 접근해야 한다(캡슐화)
     
    ```java
    Member member = new Member();  // 객체를 생성함
    
    // 도트(.) 연산자를 사용해서 필드에 접근
    member.name; // 접근 가능(public)
    member.age; // 에러 발생(private)
    
    ```
    

## 생성자(Constructor)

- 생성자는 new 연산자로 호출되는 특별한 **메소드**로 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.

- 모든 클래스는 생성자가 반드시 존재해야 하고 생성자를 하나 이상을 가질 수 있다.

- 생성자와 new 연산자에 의해 힙(Heap) 영역에 객체가 생성되고 생성된 객체의 주소가 리턴된다.

### 생성자 선언

- 생성자를 선언하는 구문은 `[접근 제한자] 클래스명([매개변수]) { ... }`이다.

- 생성자의 선언은 메서드와 다르게 반환값이 없고 **생성자명은 클래스명과 똑같이 지정**해 주어야 한다.
    - 메서드는 정의 시 자료형(반환타입)을 작성해 줘야 함

- 클래스에 생성자 선언을 생략하면 컴파일러가 내용이 비어있는 기본 생성자(Default Constructor)를 자동으로 추가해 준다.  
    - 단, 클래스에서 생성자를 한 개라도 명시적으로 선언했다면 컴파일러는 기본 생성자를 추가하지 않는다.

- 생성자도 메소드이기 때문에 오버로딩이 가능하며 오버로딩의 조건은 메소드 오버로딩과 동일하다.
    - 생성자 오버로딩을 통해서 여러 개의 생성자를 만들고 객체 생성 시 필요한 생성자를 호출해서 객체를 만들 수 있다.
    - 서로 다른 생성자를 구분하는 기준은 매개변수의 타입, 개수, 순서이다 = 매개변수의 타입과 개수, 순서가 같은 생성자는 만들 수 없다.

- 단순히 필드를 초기화하기 위한 생성자는 Alt+Ins로 쉽게 만들 수 있다.

    ```java
    public class Member {
        // 필드 정의
        private String name;
        private int age;
      
        // 생성자 정의
        // 기본 생성자
        public Member() {  // 생성자는 반환타입 없음
        } 
      
        // 매개변수가 있는 생성자 (객체 생성과 동시에 필드 초기화)
        public Member(String name, int age) {
            this.name = name;
            this.age = age;
        }
      
        // 메소드 정의
        public String information() {  // 메서드는 반환타입 지정
            return "이름은 " + this.name + ", 나이는 " +  this.age + "살 입니다.";
        }
    }
    ```
    
    ```java
    Member member1 = new Member(); // 기본 생성자 호출
    Member member2 = new Member("홍길동", 38); // 이름과 나이를 매개값으로 받는 생성자 호출
    ```
    

### this

- 객체 내부에서 객체는 자신을 `this`라고 표현한다.

- 객체 내부에서 다른 멤버에 접근하기 위해 `this`를 사용한다.

- `this`는 주로 생성자와 메소드의 매개변수 이름이 필드와 동일한 경우에 매개변수와 필드를 구분하기 위해 사용한다.

    ```java
    public Member(String name, int age) {
        this.name = name;  // this.name은 필드, 그냥 name은 매개변수
        this.age = age;
    }
    ```

### 다른 생성자 호출

- 생성자에서 다른 생성자를 호출할 때 `this()`를 사용한다. **단, 생성자의 첫 줄에서만 사용해야 한다**.

- `this()`를 통해서 생성자 간에 중복되는 코드를 제거할 수 있다.
    - 다른 생성자에서 이미 초기화한 필드를 받을 수 있음

- 메소드에서는 사용X

    ```java
    public class Member {
        private String name;
        private int age;
      
        public Member(String name) {
            this.name = name;
        }
      
        public Member(String name, int age) {
            // 생성자의 매개변수 타입과 순서에 맞게 전달해야 한다.
            this(name);  // 중복으로 작성될 코드를 제거함
            this.age = age
        }
    }
    ```
    

## 메소드(Method)

- 메소드는 객체의 기능, 동작에 해당하는 코드 블록({})이다.

- 메소드는 수학의 **함수**와 비슷하며 호출을 통해 사용한다.

- 메소드를 호출하게 되면 중괄호 블록에 있는 코드들이 순차적으로 실행한다.

- 메소드는 외부로부터 필요한 값(매개값)을 전달받을 수도 있고 메소드 실행 후 결과 값(`return`)을 반환할 수도 있다.

### 메소드 선언

- 메소드를 선언하는 구문은 `[접근 제한자] [예약어] 반환형 메소드명([매개변수]) { ... }`이다.

- 메소드 선언은 선언부(접근 제한자, 반환형, 메소드명, 매개변수)와 실행 블록({ ... })으로 구성된다.
    - 접근 제한자로는 public, protected, default, private 설정이 가능하다.

- 메소드를 호출한 곳으로 돌아가면서 결과값을 반환하기 위해 `return` 문을 사용한다.
    - 이 때 반환할 결과값의 타입을 반환형으로 선언부에 적어준다. 
    - 반환값이 없으면 반환형을 `void`로 적는다. `return`은 사용 가능하긴 한데, 값은 보낼 수 없음
    - `return` 뒤에 도달할 수 없는 위치에 코드가 있다면, 에러가 터진다


    ```java
    public class Member {
        // 필드 정의
        private String name;
        private int age;
      
        // 생성자 정의
        ...
      
        // 메소드 정의
        public String information() {
            return "이름은 " + this.name + ", 나이는 " +  this.age + "살 입니다.";
        }
    }
    ```

### 메소드 호출

- 클래스 내부의 다른 메소드에서 호출할 경우에는 메소드 이름으로 호출하면 된다.

- 클래스 외부에서 메소드를 호출할 경우에는 클래스로부터 객체를 생성한 후 메소드를 호출해야 한다.

- 메소드를 호출하고 리턴 값을 받고 싶다면 변수를 선언하고 대입하면 된다.

- 접근 제한자가 public인 메소드의 경우 도트(.) 연산자를 사용해서 메소드를 호출할 수 있다.
    
    ```java
    String info = null;
    Member member = new Member();
    
    // 객체를 생성 후 도트(.) 연산자를 사용해서 메소드에 접근
    info = member.information();  // information()의 return값을 info라는 변수에 대입
    ```

### 매개변수    

- 매개변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다. 

- 선언 시 매개변수는 `자료형 매개변수명` 형태로 선언

    ```java
    public int method4(int num1, int num2) {
        System.out.println("매개변수, 매개값 둘 다 있는 메소드");
        return num1 * num2;
    }
    ```

- 호출 시 정해진 매개변수의 개수, 타입을 맞춰서 호출해야 함

- 특정 객체로 전달받도록 설계할 수 있다
    - 객체로 전달하는 것은 주소값을 전달하는 것 = 메소드에서 수정한 내용이 메인 프레임의 객체에도 영향을 준다
    
    ```java
    public void method5(User user, String id, String password, String name)
        user.setId(id);
        user.setPassword(password);
        user.setName(name);
    ```
    ```java
    method.method5(user1, "Lee123", "password1111", "이몽룡");
    ```

- 가변인자를 전달받을 수 있다.
    1. 개수가 변할 수 있는 인자들을 배열(`new int[]{1, 2, 3}`)로 전달 - 매우 복잡하다
        ```java
        public int method6(int[] numbers) {
            int sum = 0;

            for (int i : numbers){
                sum += i;
            }
            return sum;
        }
        ```
        ```java
        System.out.println(method.method6(new int[]{1, 2, 3}));
        ```
    
    2. 가변인자를 사용하면 표현이 간단해짐. 자료형 뒤에 `...`을 붙이면, 그 자료형을 배열에 담아서 전달하는 것과 같은 동작을 함
        ```java
        public int method7(int... numbers) {
            int sum = 0;

            for (int i : numbers){
                sum += i;
            }
            return sum;
        }
        ```
        ```java
        System.out.println(method.method7(1,2,3));
        ```
        - 가장 가변인자를 잘 쓰는게 `printf()`


### 메소드 오버로딩

- 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩(Overloading)이라고 한다.

- 메소드 오버로딩을 통해서 매개값을 다양하게 받아서 필요한 처리할 수 있다.

- 메소드 오버로딩의 조건은 **매개변수의 타입, 개수, 순서** 중 하나 이상이 달라야 한다.
    - JVM이 메소드를 호출할 시점에, 매개변수가 다른 걸로 어떤 메소드를 호출해야 하는지 특정할 수 있다.

- `println` 메소드가 다양한 타입에 대해 오버로딩되어 있어 다양한 타입을 받을 수 있다.

    ```java
    // 오버로딩의 대표적인 예시
    System.out.println(1);
    System.out.println(false);
    System.out.println('A');
    System.out.println("Hello World!");
    ```

1. 매개변수의 변수명만 바꾸는 것은 메소드 오버로딩이 아니다.

2. 접근제한자만 다른 것도 오버로딩 안됨

3. 반환형만 다르고 매개변수가 동일한 것도 메소드 오버로딩이 아니다.
    - 호출 시점에 구분할 수 없기 때문

    

### Getter와 Setter 메소드

- 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것이 불가능하다.(캡슐화)
    - 메소드를 통해서 필드값을 가공한 후 외부로 전달하는 역할을 하는 메소드가 Getter이다.
    - 메소드를 통해서 검증된 유효한 값만 데이터로 저장하는 역할을 하는 메소드가 Setter이다.

    ```java
    public class Member {
        // 필드 선언
        private String name;
        private int age;
        
        // Getter & Setter
        public void setName(String name) {
            // 매개변수의 이름과 필드의 이름이 동일할 경우 this를 사용해서 필드에 접근할 수 있다.
            this.name = name;
        }
        
        public String getName() {
            return this.name;    
        }
        
        public void setAge(int age) {
            // 유효한 값만 데이터로 저장되도록 Setter 작성
            this.age = (age >= 1) ? age : 1 ;
        }
        
        public int getAge() {
            return this.age;
        }
    }
    ```

- 필드 타입이 boolean일 경우에는 Getter는 get으로 시작하지 않고 is로 시작하는 것이 관례이다.

- Getter와 Setter는 필수가 아니고, 필요에 따라 만들어야 한다.

- 간단하게 Alt+Ins로 필요한 필드에 대해 Getter, Setter를 설정할 수도 있다.